<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture-Controlled Particle System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        .glass-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }
        /* Hide scrollbar for immersive feel */
        ::-webkit-scrollbar { width: 0px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 15000,
            particleSize: 0.15,
            bloomStrength: 1.8,
            bloomRadius: 0.5,
            bloomThreshold: 0.1,
            shapes: ['HEART', 'SATURN', 'SPIRAL', 'TREE']
        };

        // --- Math & Geometry Generators ---
        const MathUtils = {
            // Procedural Glow Texture
            createTexture: () => {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const context = canvas.getContext('2d');
                const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 32, 32);
                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            },

            // Shape Generators
            getPositions: (type, count) => {
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const colorObj = new THREE.Color();

                for (let i = 0; i < count; i++) {
                    let x, y, z;
                    const i3 = i * 3;

                    if (type === 'HEART') {
                        // Heart Formula
                        const t = Math.random() * Math.PI * 2;
                        const r = Math.sqrt(Math.random()) * 20; // Volume
                        // Normalize distribution
                        const phi = Math.asin(Math.random() * 2 - 1); 
                        
                        // Parametric Heart
                        x = 16 * Math.pow(Math.sin(t), 3);
                        y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                        z = (Math.random() - 0.5) * 5; // Thickness
                        
                        // Scale down
                        x *= 0.5; y *= 0.5;
                        y += 2; // Offset center

                        colorObj.setHSL(0.95 + Math.random() * 0.1, 1.0, 0.6); // Red/Pink
                    } 
                    else if (type === 'SATURN') {
                        const isRing = Math.random() > 0.4;
                        if (isRing) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 12 + Math.random() * 6;
                            x = Math.cos(angle) * radius;
                            z = Math.sin(angle) * radius;
                            y = (Math.random() - 0.5) * 0.5;
                            
                            // Tilt
                            const tilt = 0.4;
                            const tempY = y * Math.cos(tilt) - z * Math.sin(tilt);
                            const tempZ = y * Math.sin(tilt) + z * Math.cos(tilt);
                            y = tempY; z = tempZ;
                            
                            colorObj.setHSL(0.1 + Math.random() * 0.1, 0.8, 0.6); // Gold/Orange
                        } else {
                            // Planet body
                            const r = 7;
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos(Math.random() * 2 - 1);
                            x = r * Math.sin(phi) * Math.cos(theta);
                            y = r * Math.sin(phi) * Math.sin(theta);
                            z = r * Math.cos(phi);
                            colorObj.setHSL(0.08 + Math.random() * 0.05, 0.9, 0.4); // Brownish
                        }
                    }
                    else if (type === 'SPIRAL') {
                        const t = i / count * 50; 
                        const radius = t * 0.4;
                        x = Math.cos(t) * radius;
                        z = Math.sin(t) * radius;
                        y = t - 10;
                        
                        // Add some noise width
                        x += (Math.random() - 0.5);
                        z += (Math.random() - 0.5);
                        
                        colorObj.setHSL(0.5 + i/count * 0.4, 0.9, 0.6); // Cyan to Purple
                    }
                    else if (type === 'TREE') {
                        const h = 25;
                        const yPos = (Math.random() * h) - (h/2);
                        const radius = ((h/2) - yPos) * 0.4;
                        const angle = Math.random() * Math.PI * 2;
                        
                        x = Math.cos(angle) * radius;
                        z = Math.sin(angle) * radius;
                        y = yPos;
                        
                        if (Math.random() > 0.9) {
                            // Ornaments
                            colorObj.setHSL(Math.random(), 1.0, 0.7);
                            x *= 1.1; z *= 1.1; // Pop out
                        } else {
                            // Green
                            colorObj.setHSL(0.3 + Math.random() * 0.1, 0.8, 0.4);
                        }
                    }

                    positions[i3] = x;
                    positions[i3+1] = y;
                    positions[i3+2] = z;
                    
                    colors[i3] = colorObj.r;
                    colors[i3+1] = colorObj.g;
                    colors[i3+2] = colorObj.b;
                }
                return { positions, colors };
            }
        };

        // --- Main Visual Component ---
        const ParticleCanvas = ({ shapeType, handState, setFps }) => {
            const containerRef = useRef(null);
            const requestRef = useRef();
            const sceneRef = useRef(null);
            
            // Refs for mutable data (avoid re-renders)
            const particlesRef = useRef(null);
            const targetPositionsRef = useRef(null);
            const originalColorsRef = useRef(null);
            
            useEffect(() => {
                if (!containerRef.current) return;

                // 1. Setup Scene
                const scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.02);
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 30);

                const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);

                // 2. Post Processing (Bloom)
                const composer = new EffectComposer(renderer);
                const renderPass = new RenderPass(scene, camera);
                composer.addPass(renderPass);

                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    CONFIG.bloomStrength,
                    CONFIG.bloomRadius,
                    CONFIG.bloomThreshold
                );
                composer.addPass(bloomPass);

                // 3. Controls
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 1.0;

                // 4. Particles Init
                const geometry = new THREE.BufferGeometry();
                const { positions, colors } = MathUtils.getPositions(shapeType, CONFIG.particleCount);
                
                // Store current and target data
                targetPositionsRef.current = positions; // Start at target
                originalColorsRef.current = colors;

                // Attributes
                const currentPos = new Float32Array(positions); // Clone for manipulation
                geometry.setAttribute('position', new THREE.BufferAttribute(currentPos, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: CONFIG.particleSize,
                    map: MathUtils.createTexture(),
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    opacity: 0.8
                });

                const particleSystem = new THREE.Points(geometry, material);
                scene.add(particleSystem);
                particlesRef.current = particleSystem;

                // 5. Animation Loop
                const clock = new THREE.Clock();
                let frameCount = 0;
                let lastTime = performance.now();

                const animate = () => {
                    const time = clock.getElapsedTime();
                    const delta = clock.getDelta();

                    // FPS Counter
                    frameCount++;
                    if (performance.now() - lastTime >= 1000) {
                        setFps(frameCount);
                        frameCount = 0;
                        lastTime = performance.now();
                    }

                    // Physics & Morphing Logic
                    const positions = particleSystem.geometry.attributes.position.array;
                    const targets = targetPositionsRef.current;
                    
                    // Interaction Factor: 0 = Morph (Implode), 1 = Explode
                    // handState.openness is 0 (Fist) to 1 (Open)
                    // We want: Fist = Morph (0), Open = Explode (1)
                    const explosionFactor = handState.openness; 

                    for (let i = 0; i < CONFIG.particleCount; i++) {
                        const i3 = i * 3;
                        
                        // Base Target (Shape)
                        let tx = targets[i3];
                        let ty = targets[i3+1];
                        let tz = targets[i3+2];

                        // Breathing Effect (Sine wave based on index and time)
                        const breathe = 1 + Math.sin(time * 2 + i * 0.01) * 0.05;
                        tx *= breathe; ty *= breathe; tz *= breathe;

                        // Explosion Logic
                        if (explosionFactor > 0.1) {
                            // Push out based on openness
                            // Using simple noise-like dispersal
                            const noiseX = Math.sin(i * 12.3 + time) * 20 * explosionFactor;
                            const noiseY = Math.cos(i * 22.4 + time) * 20 * explosionFactor;
                            const noiseZ = Math.sin(i * 33.5 + time) * 20 * explosionFactor;
                            
                            tx += noiseX;
                            ty += noiseY;
                            tz += noiseZ;
                        }

                        // Lerp towards target (Soft physics)
                        // Faster if creating shape (magnetic), slower if floating
                        const speed = 0.05 + (1.0 - explosionFactor) * 0.1; 
                        
                        positions[i3] += (tx - positions[i3]) * speed;
                        positions[i3+1] += (ty - positions[i3+1]) * speed;
                        positions[i3+2] += (tz - positions[i3+2]) * speed;
                    }

                    particleSystem.geometry.attributes.position.needsUpdate = true;
                    
                    // Rotate based on interaction
                    particleSystem.rotation.y += 0.001 * (1 - explosionFactor); 

                    controls.update();
                    composer.render();
                    requestRef.current = requestAnimationFrame(animate);
                };

                animate();

                // Resize Handler
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    cancelAnimationFrame(requestRef.current);
                    containerRef.current.removeChild(renderer.domElement);
                    geometry.dispose();
                    material.dispose();
                };
            }, [shapeType]); // Re-init if shape type changes hard (though we handle morphs via refs usually, for simplicity we re-gen here)

            // Dynamic Shape Update without full re-render
            useEffect(() => {
                if(!particlesRef.current) return;
                const { positions, colors } = MathUtils.getPositions(shapeType, CONFIG.particleCount);
                targetPositionsRef.current = positions;
                // Update colors immediately for visual feedback
                particlesRef.current.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particlesRef.current.geometry.attributes.color.needsUpdate = true;
            }, [shapeType]);

            return <div ref={containerRef} className="absolute inset-0 z-0" />;
        };

        // --- Camera & Gesture Logic ---
        const GestureController = ({ onUpdate }) => {
            const videoRef = useRef(null);

            useEffect(() => {
                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0, // Lite model for speed
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const landmarks = results.multiHandLandmarks[0];
                        
                        // Calculate "Openness"
                        // Distance between Wrist (0) and Middle Finger Tip (12) vs Wrist and Middle Finger Base (9)
                        // Simple heuristic: if tip is close to palm base, it's a fist.
                        
                        const wrist = landmarks[0];
                        const middleTip = landmarks[12];
                        const middleBase = landmarks[9]; // MCP

                        const distTipToWrist = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
                        const distBaseToWrist = Math.hypot(middleBase.x - wrist.x, middleBase.y - wrist.y);
                        
                        // Ratio: > 1.8 usually open, < 1.0 usually fist
                        let ratio = distTipToWrist / distBaseToWrist;
                        
                        // Normalize ratio to 0 (Fist) - 1 (Open)
                        // Empirically: Fist ~0.8-1.0, Open ~2.0+
                        let openness = (ratio - 0.8) / 1.2;
                        openness = Math.max(0, Math.min(1, openness));

                        onUpdate({
                            detected: true,
                            openness: openness
                        });
                    } else {
                        onUpdate({ detected: false, openness: 0 }); // Default to Morph (Implode) if no hand
                    }
                });

                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    const camera = new Camera(videoRef.current, {
                        onFrame: async () => {
                            await hands.send({image: videoRef.current});
                        },
                        width: 640,
                        height: 480
                    });
                    camera.start();
                }
            }, []);

            // Hidden video element
            return <video ref={videoRef} className="hidden" playsInline muted />;
        };

        // --- UI & App Root ---
        const App = () => {
            const [shape, setShape] = useState('HEART');
            const [handState, setHandState] = useState({ detected: false, openness: 0 }); // 0 = fist, 1 = open
            const [fps, setFps] = useState(0);
            const [uiOpen, setUiOpen] = useState(true);

            return (
                <div className="relative w-screen h-screen font-sans text-white">
                    {/* 3D Scene */}
                    <ParticleCanvas shapeType={shape} handState={handState} setFps={setFps} />

                    {/* Camera Logic (Invisible) */}
                    <GestureController onUpdate={setHandState} />

                    {/* UI Overlay */}
                    <div className={`absolute top-4 left-4 z-50 transition-all duration-300 ${uiOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}>
                        <div className="glass-panel p-6 rounded-xl w-64">
                            <h1 className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-purple-400 to-pink-600 mb-2">
                                Particle Alchemist
                            </h1>
                            <div className="text-xs text-gray-400 mb-4 flex justify-between">
                                <span>FPS: {fps}</span>
                                <span className={handState.detected ? "text-green-400" : "text-red-400"}>
                                    {handState.detected ? "● CAM ACTIVE" : "● CAM SEARCHING"}
                                </span>
                            </div>

                            <div className="space-y-3">
                                <p className="text-xs font-semibold uppercase tracking-wider text-gray-500">Morph Target</p>
                                <div className="grid grid-cols-2 gap-2">
                                    {CONFIG.shapes.map(s => (
                                        <button 
                                            key={s}
                                            onClick={() => setShape(s)}
                                            className={`text-xs py-2 px-3 rounded border transition-all ${
                                                shape === s 
                                                ? 'bg-white/20 border-white/40 text-white shadow-lg shadow-purple-500/20' 
                                                : 'border-white/10 text-gray-400 hover:bg-white/5'
                                            }`}
                                        >
                                            {s}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="mt-6 pt-4 border-t border-white/10">
                                <div className="flex items-center justify-between mb-2">
                                    <span className="text-xs text-gray-400">Hand State</span>
                                    <span className="text-xs font-mono">{handState.openness > 0.5 ? "EXPLODE" : "IMPLODE"}</span>
                                </div>
                                <div className="h-1.5 w-full bg-gray-800 rounded-full overflow-hidden">
                                    <div 
                                        className="h-full bg-gradient-to-r from-blue-500 to-purple-500 transition-all duration-100 ease-out"
                                        style={{ width: `${handState.openness * 100}%` }}
                                    />
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Toggle Button */}
                    <button 
                        onClick={() => setUiOpen(!uiOpen)}
                        className="absolute bottom-6 right-6 z-50 glass-panel p-3 rounded-full hover:bg-white/10 transition-colors"
                    >
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" />
                        </svg>
                    </button>

                    {/* Instructions */}
                    {!handState.detected && (
                        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none">
                            <p className="text-white/50 text-sm animate-pulse">Waiting for Camera / Show Hand...</p>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>