<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Alchemist V2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        /* GUI Customization */
        .lil-gui { --background-color: rgba(20, 20, 20, 0.8); --text-color: #eee; --title-background-color: #ff4081; }
        .glass-loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.5); font-family: monospace; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- Global Config & Colors (Mutable for GUI) ---
        const PARAMS = {
            particleCount: 20000,
            particleSize: 0.12,
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0.1,
            // Colors
            heartColor: '#ff0055',
            spiralInner: '#00ffff',
            spiralOuter: '#ff00ff',
            treeLeaf: '#00ff44',
            treeOrnament: '#ffaa00',
            saturnBody: '#ffcc00',
            saturnRing: '#8888ff'
        };

        // --- Math Generators ---
        const MathUtils = {
            createTexture: () => {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.4, 'rgba(255,255,255,0.3)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 32, 32);
                return new THREE.CanvasTexture(canvas);
            },

            getPositions: (type, count) => {
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const c1 = new THREE.Color();
                const c2 = new THREE.Color();

                let ptr = 0;

                if (type === 'HEART') {
                    // 3D Solid Heart using Rejection Sampling
                    // Inequality: (x^2 + 9/4y^2 + z^2 - 1)^3 - x^2z^3 - 9/80y^2z^3 < 0
                    c1.set(PARAMS.heartColor);
                    while (ptr < count) {
                        const x = (Math.random() * 2 - 1) * 1.5;
                        const y = (Math.random() * 2 - 1) * 1.5;
                        const z = (Math.random() * 2 - 1) * 1.5;

                        const a = x*x + (9/4)*y*y + z*z - 1;
                        if (a*a*a - x*x*z*z*z - (9/80)*y*y*z*z*z < 0) {
                            // Scale up
                            positions[ptr*3] = x * 10;
                            positions[ptr*3+1] = y * 10 + 2; // Lift up slightly
                            positions[ptr*3+2] = z * 10;
                            
                            // Color gradient based on depth
                            const depth = (z + 1.5) / 3;
                            colors[ptr*3] = c1.r + depth * 0.2;
                            colors[ptr*3+1] = c1.g;
                            colors[ptr*3+2] = c1.b + depth * 0.2;
                            ptr++;
                        }
                    }
                } 
                else if (type === 'SPIRAL') {
                    // Galaxy Spiral (Planar, Inward)
                    c1.set(PARAMS.spiralInner);
                    c2.set(PARAMS.spiralOuter);
                    for (let i = 0; i < count; i++) {
                        const branchAngle = (i % 3) * ((2 * Math.PI) / 3); // 3 Arms
                        const radius = Math.random() * 15 + 1; // 1 to 16
                        
                        // Logarithmic spiral formula approximation
                        const spinAngle = radius * 0.5; 
                        
                        const angle = branchAngle + spinAngle;
                        
                        // Randomness in the arm width
                        const randomOffset = (Math.random() - 0.5) * (0.5 + radius * 0.1); 

                        const x = Math.cos(angle) * radius + randomOffset;
                        const z = Math.sin(angle) * radius + randomOffset;
                        const y = (Math.random() - 0.5) * (0.5 + radius * 0.05); // Flat disk with slight volume at center

                        positions[i*3] = x;
                        positions[i*3+1] = y;
                        positions[i*3+2] = z;

                        // Color mixing based on radius
                        const mix = radius / 16;
                        colors[i*3] = c1.r * (1-mix) + c2.r * mix;
                        colors[i*3+1] = c1.g * (1-mix) + c2.g * mix;
                        colors[i*3+2] = c1.b * (1-mix) + c2.b * mix;
                    }
                }
                else if (type === 'TREE') {
                    c1.set(PARAMS.treeLeaf);
                    c2.set(PARAMS.treeOrnament);
                    for (let i = 0; i < count; i++) {
                        const h = 25;
                        const yPos = (Math.random() * h) - (h/2); // -12.5 to 12.5
                        const relY = (yPos + h/2) / h; // 0 to 1 (bottom to top)
                        
                        // Cone radius gets smaller as we go up
                        const maxRadius = 10 * (1 - relY);
                        // Fill volume? Or surface? Let's do surface + slight volume
                        const r = Math.sqrt(Math.random()) * maxRadius; 
                        const angle = Math.random() * Math.PI * 2;

                        positions[i*3] = Math.cos(angle) * r;
                        positions[i*3+1] = yPos;
                        positions[i*3+2] = Math.sin(angle) * r;

                        // Decorations: If point is near the outer edge, small chance to be an ornament
                        const isEdge = r > maxRadius * 0.85;
                        if (isEdge && Math.random() > 0.85) {
                            colors[i*3] = c2.r;
                            colors[i*3+1] = c2.g;
                            colors[i*3+2] = c2.b;
                            // Push ornaments out slightly
                            positions[i*3] *= 1.05;
                            positions[i*3+2] *= 1.05;
                        } else {
                            colors[i*3] = c1.r * (0.5 + Math.random()*0.5); // Varying green
                            colors[i*3+1] = c1.g * (0.5 + Math.random()*0.5);
                            colors[i*3+2] = c1.b * (0.5 + Math.random()*0.5);
                        }
                    }
                }
                else if (type === 'SATURN') {
                     c1.set(PARAMS.saturnBody);
                     c2.set(PARAMS.saturnRing);
                     for(let i=0; i<count; i++) {
                         // 70% Body, 30% Rings
                         if (Math.random() > 0.35) {
                             // Body (Sphere)
                             const r = 6;
                             const u = Math.random();
                             const v = Math.random();
                             const theta = 2 * Math.PI * u;
                             const phi = Math.acos(2 * v - 1);
                             
                             positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                             positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                             positions[i*3+2] = r * Math.cos(phi);
                             
                             colors[i*3] = c1.r; colors[i*3+1] = c1.g; colors[i*3+2] = c1.b;
                         } else {
                             // Ring (Disk)
                             const angle = Math.random() * Math.PI * 2;
                             const dist = 9 + Math.random() * 6; // 9 to 15
                             const x = Math.cos(angle) * dist;
                             const z = Math.sin(angle) * dist;
                             
                             // Tilt the ring
                             const tilt = 0.5;
                             const y = x * Math.sin(tilt); // Simple tilt on one axis approx
                             
                             positions[i*3] = x * Math.cos(tilt);
                             positions[i*3+1] = y;
                             positions[i*3+2] = z;

                             colors[i*3] = c2.r; colors[i*3+1] = c2.g; colors[i*3+2] = c2.b;
                         }
                     }
                }

                return { positions, colors };
            }
        };

        // --- 3D Scene Component ---
        const Scene = ({ shape, handState }) => {
            const mountRef = useRef(null);
            
            // Refs for Animation Loop Access
            const particlesRef = useRef(null);
            const targetPosRef = useRef(null);
            const handStateRef = useRef(handState);
            const paramsRef = useRef(PARAMS);

            // Update hand state ref instantly
            useEffect(() => { handStateRef.current = handState; }, [handState]);

            useEffect(() => {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // 1. Scene Setup
                const scene = new THREE.Scene();
                // scene.fog = new THREE.FogExp2(0x050505, 0.02);

                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
                camera.position.set(0, 0, 35);

                const renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", alpha: false });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                mountRef.current.appendChild(renderer.domElement);

                // 2. Post Processing
                const composer = new EffectComposer(renderer);
                composer.addPass(new RenderPass(scene, camera));
                
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);
                composer.addPass(bloomPass);

                // 3. GUI Setup
                const gui = new GUI({ title: 'Visual Controls' });
                const updateGeometryColors = () => {
                   // Function to refresh colors based on shape
                   if (!particlesRef.current) return;
                   const { colors } = MathUtils.getPositions(shape, PARAMS.particleCount);
                   particlesRef.current.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                   particlesRef.current.geometry.attributes.color.needsUpdate = true;
                };

                const f1 = gui.addFolder('Bloom');
                f1.add(PARAMS, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);
                f1.add(PARAMS, 'bloomRadius', 0, 1).onChange(v => bloomPass.radius = v);
                f1.add(PARAMS, 'bloomThreshold', 0, 1).onChange(v => bloomPass.threshold = v);
                
                const f2 = gui.addFolder('Colors');
                f2.addColor(PARAMS, 'heartColor').name('Heart').onChange(updateGeometryColors);
                f2.addColor(PARAMS, 'spiralInner').name('Galaxy Core').onChange(updateGeometryColors);
                f2.addColor(PARAMS, 'spiralOuter').name('Galaxy Edge').onChange(updateGeometryColors);
                f2.addColor(PARAMS, 'treeLeaf').name('Tree Leaf').onChange(updateGeometryColors);
                f2.addColor(PARAMS, 'treeOrnament').name('Ornament').onChange(updateGeometryColors);

                // 4. Particle System
                const geometry = new THREE.BufferGeometry();
                const { positions, colors } = MathUtils.getPositions(shape, PARAMS.particleCount);
                
                targetPosRef.current = positions; // Target destination
                
                // Initialize positions randomly for explosion effect start
                const currentPos = new Float32Array(positions.length);
                for(let i=0; i<positions.length; i++) currentPos[i] = (Math.random()-0.5) * 50;

                geometry.setAttribute('position', new THREE.BufferAttribute(currentPos, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: PARAMS.particleSize,
                    map: MathUtils.createTexture(),
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true
                });

                const particles = new THREE.Points(geometry, material);
                scene.add(particles);
                particlesRef.current = particles;

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.5;

                // 5. Animation Loop
                const clock = new THREE.Clock();
                let animationId;

                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    const time = clock.getElapsedTime();

                    // --- KEY FIX: Read from Ref, not captured scope variable ---
                    const currentHand = handStateRef.current; 
                    
                    // Logic: 0 = Morph (Assemble), 1 = Explode (Disassemble)
                    const openness = currentHand.detected ? currentHand.openness : 0;
                    
                    const positions = particles.geometry.attributes.position.array;
                    const targets = targetPosRef.current;

                    for (let i = 0; i < PARAMS.particleCount; i++) {
                        const i3 = i * 3;
                        let tx = targets[i3];
                        let ty = targets[i3+1];
                        let tz = targets[i3+2];

                        // Breathing for liveliness
                        const breathe = 1 + Math.sin(time * 1.5 + i*0.02) * 0.03;
                        
                        // Explosion Force
                        // If openness is high, push particles OUT from center + Noise
                        let forceX = 0, forceY = 0, forceZ = 0;
                        
                        if (openness > 0.1) {
                            const explMult = openness * 15; // Max explosion distance
                            // Use simple trig noise
                            forceX = Math.sin(i * 0.1 + time) * explMult;
                            forceY = Math.cos(i * 0.2 + time) * explMult;
                            forceZ = Math.sin(i * 0.3 + time) * explMult;
                        }

                        // Final Target Calculation
                        const destX = tx * breathe + forceX;
                        const destY = ty * breathe + forceY;
                        const destZ = tz * breathe + forceZ;

                        // Lerp Speed: High Openness = Fast Response (Snap), Low = Smooth Morph
                        // But actually, we want Magnetic snap when closing hand (openness -> 0)
                        // And Explode when opening. 
                        const lerpFactor = 0.08; 

                        positions[i3] += (destX - positions[i3]) * lerpFactor;
                        positions[i3+1] += (destY - positions[i3+1]) * lerpFactor;
                        positions[i3+2] += (destZ - positions[i3+2]) * lerpFactor;
                    }

                    particles.geometry.attributes.position.needsUpdate = true;
                    
                    // Rotate slightly faster when exploded
                    particles.rotation.y += 0.001 + (openness * 0.01);
                    
                    controls.update();
                    composer.render();
                };

                animate();

                // Cleanup
                return () => {
                    cancelAnimationFrame(animationId);
                    mountRef.current.removeChild(renderer.domElement);
                    gui.destroy();
                    geometry.dispose();
                    material.dispose();
                };
            }, []); // Run once on mount

            // React to Shape Change separately to regenerate Geometry
            useEffect(() => {
                if (!particlesRef.current) return;
                const { positions, colors } = MathUtils.getPositions(shape, PARAMS.particleCount);
                targetPosRef.current = positions; // Update target buffer
                
                // Animate transition of Colors immediately
                particlesRef.current.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particlesRef.current.geometry.attributes.color.needsUpdate = true;
            }, [shape]);

            return <div ref={mountRef} className="absolute inset-0" />;
        };

        // --- Camera Controller (Invisible) ---
        const CameraController = ({ onUpdate }) => {
            const videoRef = useRef(null);
            useEffect(() => {
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                
                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const lm = results.multiHandLandmarks[0];
                        // Distance: Wrist(0) to MiddleTip(12) vs Wrist(0) to MiddleMCP(9)
                        const d1 = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y);
                        const d2 = Math.hypot(lm[9].x - lm[0].x, lm[9].y - lm[0].y);
                        
                        // Ratio: ~1.0 = Fist, ~2.0+ = Open
                        let val = (d1/d2 - 0.8) / 1.0; 
                        onUpdate({ detected: true, openness: Math.max(0, Math.min(1, val)) });
                    } else {
                        onUpdate({ detected: false, openness: 0 });
                    }
                });

                if (navigator.mediaDevices?.getUserMedia) {
                    const camera = new Camera(videoRef.current, {
                        onFrame: async () => await hands.send({image: videoRef.current}),
                        width: 640, height: 480
                    });
                    camera.start();
                }
            }, []);
            return <video ref={videoRef} className="hidden" playsInline muted />;
        };

        // --- Main App ---
        const App = () => {
            const [shape, setShape] = useState('HEART');
            const [handState, setHandState] = useState({ detected: false, openness: 0 });

            return (
                <div className="w-full h-full">
                    <Scene shape={shape} handState={handState} />
                    <CameraController onUpdate={setHandState} />
                    
                    {/* UI Overlay */}
                    <div className="absolute top-6 left-6 z-10 pointer-events-none">
                        <h1 className="text-2xl font-bold text-white tracking-widest uppercase drop-shadow-[0_0_10px_rgba(255,0,255,0.8)]">
                            Particle Engine <span className="text-pink-500">V2</span>
                        </h1>
                        <div className="flex items-center gap-2 mt-2">
                             <div className={`w-3 h-3 rounded-full ${handState.detected ? 'bg-green-500 shadow-[0_0_10px_#0f0]' : 'bg-red-500 animate-pulse'}`}></div>
                             <span className="text-xs text-white/70 font-mono">
                                {handState.detected ? `SYNCED: ${(handState.openness*100).toFixed(0)}%` : "SEARCHING HAND..."}
                             </span>
                        </div>
                    </div>

                    <div className="absolute bottom-8 left-1/2 -translate-x-1/2 flex gap-4 z-20">
                        {['HEART', 'SATURN', 'SPIRAL', 'TREE'].map(s => (
                            <button key={s} onClick={() => setShape(s)}
                                className={`px-6 py-2 rounded-full border border-white/20 text-sm font-bold tracking-widest backdrop-blur-md transition-all
                                ${shape === s ? 'bg-white/10 text-white shadow-[0_0_20px_rgba(255,0,255,0.5)] border-pink-500/50' : 'text-gray-400 hover:bg-white/5 hover:text-white'}`}
                            >
                                {s}
                            </button>
                        ))}
                    </div>
                    
                    {!handState.detected && (
                        <div className="glass-loader text-center">
                            <p>Initializing Vision Core...</p>
                            <p className="text-xs mt-2 opacity-50">Please allow camera access</p>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>