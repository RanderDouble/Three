<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Alchemist V4 - Edges & Axis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; }
        canvas { display: block; }
        .lil-gui { --background-color: rgba(10, 10, 10, 0.9); --text-color: #eee; --title-background-color: #ff0055; }
        .glass-loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255,255,255,0.5); font-family: monospace; pointer-events: none; }
        .axis-label { position: absolute; color: white; font-family: monospace; font-size: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- V4 Config ---
        const PARAMS = {
            particleCount: 65000, 
            particleSize: 0.07,   
            bloomStrength: 1.4,
            bloomRadius: 0.4,
            bloomThreshold: 0.1,
            showAxes: true, // Toggle for Axis Helper
            autoRotate: true,
            // Colors
            heartColor: '#ff0033',
            heartEdge: '#ffffff', // High contrast white edge
            spiralInner: '#00aaff',
            spiralOuter: '#ff00aa',
            treeLeaf: '#00ff55',
            treeRibbon: '#ffdd00',
            saturnBody: '#ffaa00',
            saturnRing: '#4444ff',
            saturnEdge: '#ffffff' // Ring edge
        };

        const MathUtils = {
            createTexture: () => {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                // Sharper center for better edge definition
                const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 32, 32);
                return new THREE.CanvasTexture(canvas);
            },

            getPositions: (type, totalCount) => {
                const positions = new Float32Array(totalCount * 3);
                const colors = new Float32Array(totalCount * 3);
                const cMain = new THREE.Color();
                const cEdge = new THREE.Color();
                const cSec = new THREE.Color();

                // Allocate particles: 15% for Edges, 85% for Volume
                const edgeCount = Math.floor(totalCount * 0.15);
                const volCount = totalCount - edgeCount;
                
                let ptr = 0;

                if (type === 'HEART') {
                    cMain.set(PARAMS.heartColor);
                    cEdge.set(PARAMS.heartEdge);

                    // 1. Outline (Edges) - High density on the curve
                    for (let i = 0; i < edgeCount; i++) {
                        const t = (i / edgeCount) * Math.PI * 2;
                        // Parametric Heart Curve (2D Outline)
                        const x = 16 * Math.pow(Math.sin(t), 3);
                        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                        const z = 0; // Flat outline
                        
                        // Scale slightly larger than volume to be visible
                        positions[ptr*3] = x; 
                        positions[ptr*3+1] = y + 2; 
                        positions[ptr*3+2] = z;
                        
                        // Pure white/bright color for edge
                        colors[ptr*3] = cEdge.r; colors[ptr*3+1] = cEdge.g; colors[ptr*3+2] = cEdge.b;
                        ptr++;
                    }

                    // 2. Volume (Inside)
                    let volIdx = 0;
                    while (volIdx < volCount) {
                        const x = (Math.random() * 2 - 1) * 1.5;
                        const y = (Math.random() * 2 - 1) * 1.5;
                        const z = (Math.random() * 2 - 1) * 1.5;
                        // Heart Inequality
                        const a = x*x + (9/4)*y*y + z*z - 1;
                        if (a*a*a - x*x*z*z*z - (9/80)*y*y*z*z*z < 0) {
                            positions[ptr*3] = x * 10;
                            positions[ptr*3+1] = y * 10 + 2;
                            positions[ptr*3+2] = z * 10;
                            
                            // Darker red for volume to make edge pop
                            const depth = (z + 1.5) / 3;
                            colors[ptr*3] = cMain.r * (0.4 + depth*0.4);
                            colors[ptr*3+1] = cMain.g * (0.4 + depth*0.4);
                            colors[ptr*3+2] = cMain.b * (0.4 + depth*0.4);
                            ptr++; volIdx++;
                        }
                    }
                } 
                else if (type === 'SATURN') {
                    cMain.set(PARAMS.saturnBody);
                    cSec.set(PARAMS.saturnRing);
                    cEdge.set(PARAMS.saturnEdge);

                    // 1. Edges (Ring Borders)
                    const rings = [9, 14.5]; // Inner and Outer radius
                    for (let i = 0; i < edgeCount; i++) {
                        const rIndex = i % 2; // Toggle between inner and outer ring
                        const radius = rings[rIndex];
                        const angle = Math.random() * Math.PI * 2;
                        
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        const tilt = 0.4;
                        
                        positions[ptr*3] = x * Math.cos(tilt);
                        positions[ptr*3+1] = x * Math.sin(tilt);
                        positions[ptr*3+2] = z;

                        colors[ptr*3] = cEdge.r; colors[ptr*3+1] = cEdge.g; colors[ptr*3+2] = cEdge.b;
                        ptr++;
                    }

                    // 2. Volume (Body + Ring Surface)
                    for (let i = 0; i < volCount; i++) {
                         if (Math.random() > 0.4) { 
                             // Body
                             const r = 7 * Math.pow(Math.random(), 1/3);
                             const theta = Math.random() * Math.PI * 2;
                             const phi = Math.acos(2 * Math.random() - 1);
                             positions[ptr*3] = r * Math.sin(phi) * Math.cos(theta);
                             positions[ptr*3+1] = r * Math.sin(phi) * Math.sin(theta);
                             positions[ptr*3+2] = r * Math.cos(phi);
                             colors[ptr*3] = cMain.r; colors[ptr*3+1] = cMain.g; colors[ptr*3+2] = cMain.b;
                         } else {
                             // Ring Surface
                             const angle = Math.random() * Math.PI * 2;
                             const dist = 9 + Math.pow(Math.random(), 1.5) * 5.5; 
                             const x = Math.cos(angle) * dist;
                             const z = Math.sin(angle) * dist;
                             const tilt = 0.4;
                             positions[ptr*3] = x * Math.cos(tilt);
                             positions[ptr*3+1] = x * Math.sin(tilt);
                             positions[ptr*3+2] = z;
                             colors[ptr*3] = cSec.r * 0.6; colors[ptr*3+1] = cSec.g * 0.6; colors[ptr*3+2] = cSec.b * 0.6;
                         }
                         ptr++;
                    }
                }
                else {
                    // Default fallback for other shapes (keep previous logic logic simpler for brevity)
                    return MathUtils.getOldPositions(type, totalCount);
                }
                return { positions, colors };
            },

            // Helper for Tree/Spiral (kept simple from V3)
            getOldPositions: (type, count) => {
                 const positions = new Float32Array(count * 3);
                 const colors = new Float32Array(count * 3);
                 const c1 = new THREE.Color(type==='TREE'?PARAMS.treeLeaf:PARAMS.spiralInner);
                 const c2 = new THREE.Color(type==='TREE'?PARAMS.treeRibbon:PARAMS.spiralOuter);
                 
                 for(let i=0; i<count; i++) {
                    let x=0,y=0,z=0;
                    if(type==='TREE') {
                        const h=28; const yPos=(Math.random()*h)-(h/2); const r=Math.random()*10*(1-(yPos+h/2)/h); const a=Math.random()*6.28;
                        x=Math.cos(a)*r; y=yPos; z=Math.sin(a)*r;
                        if(Math.random()>0.85) { colors[i*3]=c2.r; colors[i*3+1]=c2.g; colors[i*3+2]=c2.b; x*=1.1; z*=1.1; }
                        else { colors[i*3]=c1.r; colors[i*3+1]=c1.g; colors[i*3+2]=c1.b; }
                    } else {
                        const r=Math.random()*18; const a=r*0.5 + (i%3)*2.1; 
                        x=Math.cos(a)*r; z=Math.sin(a)*r; y=(Math.random()-0.5);
                        colors[i*3]=c1.r; colors[i*3+1]=c1.g; colors[i*3+2]=c1.b;
                    }
                    positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
                 }
                 return {positions, colors};
            }
        };

        const Scene = ({ shape, handState }) => {
            const mountRef = useRef(null);
            const particlesRef = useRef(null);
            const targetPosRef = useRef(null);
            const handStateRef = useRef(handState);
            const shapeRef = useRef(shape);
            const axesRef = useRef(null); // Ref for Axis Helper

            useEffect(() => { handStateRef.current = handState; }, [handState]);
            useEffect(() => { shapeRef.current = shape; }, [shape]);

            useEffect(() => {
                const width = window.innerWidth; const height = window.innerHeight;
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
                camera.position.set(0, 0, 40); // Pull back slightly to see rotation

                const renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", antialias: false });
                renderer.setSize(width, height);
                mountRef.current.appendChild(renderer.domElement);

                // --- AXES HELPER ---
                const axesHelper = new THREE.AxesHelper(20);
                scene.add(axesHelper);
                axesRef.current = axesHelper;

                const composer = new EffectComposer(renderer);
                composer.addPass(new RenderPass(scene, camera));
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), PARAMS.bloomStrength, PARAMS.bloomRadius, PARAMS.bloomThreshold);
                composer.addPass(bloomPass);

                // GUI
                const gui = new GUI({ title: 'V4 Controls' });
                const updateColors = () => {
                   if (!particlesRef.current) return;
                   const { colors } = MathUtils.getPositions(shapeRef.current, PARAMS.particleCount);
                   particlesRef.current.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                   particlesRef.current.geometry.attributes.color.needsUpdate = true;
                };
                
                gui.add(PARAMS, 'showAxes').name('Show Axes (RGB)').onChange(v => axesHelper.visible = v);
                gui.add(PARAMS, 'autoRotate').name('Auto Rotation');
                
                const f2 = gui.addFolder('Colors & Edges');
                f2.addColor(PARAMS, 'heartColor').name('Heart Body').onChange(updateColors);
                f2.addColor(PARAMS, 'heartEdge').name('Heart Outline').onChange(updateColors);
                f2.addColor(PARAMS, 'saturnEdge').name('Saturn Rings').onChange(updateColors);

                // Initial Particle Setup
                const geometry = new THREE.BufferGeometry();
                const { positions, colors } = MathUtils.getPositions(shape, PARAMS.particleCount);
                targetPosRef.current = positions;
                const currentPos = new Float32Array(positions);
                geometry.setAttribute('position', new THREE.BufferAttribute(currentPos, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: PARAMS.particleSize,
                    map: MathUtils.createTexture(),
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    opacity: 0.8
                });

                const particles = new THREE.Points(geometry, material);
                scene.add(particles);
                particlesRef.current = particles;

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                // Animation
                const clock = new THREE.Clock();
                let animationId;

                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    const time = clock.getElapsedTime();
                    const currentHand = handStateRef.current; 
                    const openness = currentHand.detected ? currentHand.openness : 0;
                    
                    const positions = particles.geometry.attributes.position.array;
                    const targets = targetPosRef.current;

                    // Morphing
                    for (let i = 0; i < PARAMS.particleCount; i++) {
                        const i3 = i * 3;
                        let tx = targets[i3];
                        let ty = targets[i3+1];
                        let tz = targets[i3+2];

                        // Explosion Logic
                        if (openness > 0.05) {
                            const explMult = openness * 15;
                            tx += (Math.random()-0.5) * explMult;
                            ty += (Math.random()-0.5) * explMult;
                            tz += (Math.random()-0.5) * explMult;
                        }

                        // Lerp
                        const lerpSpeed = 0.05 + (1.0-openness) * 0.05;
                        positions[i3] += (tx - positions[i3]) * lerpSpeed;
                        positions[i3+1] += (ty - positions[i3+1]) * lerpSpeed;
                        positions[i3+2] += (tz - positions[i3+2]) * lerpSpeed;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;

                    // --- V4 ROTATION LOGIC ---
                    if (PARAMS.autoRotate) {
                        const rotSpeed = 0.005 + (openness * 0.02);
                        
                        // Heart specifically rotates around Y (Green Axis)
                        // This makes the "wings" come out of the screen
                        if (shapeRef.current === 'HEART') {
                            particles.rotation.y += rotSpeed;
                            particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05); // Stabilize X
                            particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0, 0.05); // Stabilize Z
                        } else {
                            // Others can rotate normally
                            particles.rotation.y += rotSpeed;
                        }
                    }

                    controls.update();
                    composer.render();
                };
                animate();

                // Resize
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    cancelAnimationFrame(animationId);
                    mountRef.current.removeChild(renderer.domElement);
                    gui.destroy(); geometry.dispose(); material.dispose();
                };
            }, []);

            useEffect(() => {
                if (!particlesRef.current) return;
                const { positions, colors } = MathUtils.getPositions(shape, PARAMS.particleCount);
                targetPosRef.current = positions;
                particlesRef.current.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particlesRef.current.geometry.attributes.color.needsUpdate = true;
            }, [shape]);

            return <div ref={mountRef} className="absolute inset-0" />;
        };

        // --- Camera Controller ---
        const CameraController = ({ onUpdate }) => {
            const videoRef = useRef(null);
            useEffect(() => {
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 0 });
                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const lm = results.multiHandLandmarks[0];
                        const d1 = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y);
                        const d2 = Math.hypot(lm[9].x - lm[0].x, lm[9].y - lm[0].y);
                        onUpdate({ detected: true, openness: Math.max(0, Math.min(1, (d1/d2 - 0.8) / 1.2)) });
                    } else {
                        onUpdate({ detected: false, openness: 0 });
                    }
                });
                if (navigator.mediaDevices?.getUserMedia) {
                    const camera = new Camera(videoRef.current, {
                        onFrame: async () => await hands.send({image: videoRef.current}),
                        width: 640, height: 480
                    });
                    camera.start();
                }
            }, []);
            return <video ref={videoRef} className="hidden" playsInline muted />;
        };

        const App = () => {
            const [shape, setShape] = useState('HEART');
            const [handState, setHandState] = useState({ detected: false, openness: 0 });
            return (
                <div className="w-full h-full font-sans">
                    <Scene shape={shape} handState={handState} />
                    <CameraController onUpdate={setHandState} />
                    
                    {/* UI V4 */}
                    <div className="absolute top-4 left-4 text-white/50 text-xs font-mono pointer-events-none">
                        <p>AXIS GUIDE:</p>
                        <p className="text-red-500">RED = X (Horizontal)</p>
                        <p className="text-green-500">GREEN = Y (Tips Axis)</p>
                        <p className="text-blue-500">BLUE = Z (Depth)</p>
                    </div>

                    <div className="absolute bottom-10 left-1/2 -translate-x-1/2 flex gap-3 z-20">
                        {['HEART', 'SATURN', 'SPIRAL', 'TREE'].map(s => (
                            <button key={s} onClick={() => setShape(s)}
                                className={`px-5 py-2 rounded-sm text-xs font-black tracking-[0.2em] transition-all border
                                ${shape === s ? 'bg-pink-600 border-pink-500 text-white scale-110 shadow-[0_0_25px_rgba(255,0,100,0.6)]' : 'bg-black/50 border-white/10 text-white/50 hover:text-white hover:border-white/50'}`}
                            >
                                {s}
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>